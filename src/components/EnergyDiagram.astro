---
// EnergyDiagram.astro - Energy profile diagram component for Astro

interface EnergyPoint {
  name: string;
  energy: number;
  transitionState?: boolean;
}

interface Props {
  data: EnergyPoint[];
  width?: number;
  height?: number;
  title?: string;
  yLabel?: string;
  xLabel?: string;
  energyUnit?: string;
  colors?: {
    line?: string;
    point?: string;
    text?: string;
    transitionState?: string;
    background?: string;
  };
  fontSize?: number;
  lineWidth?: number;
}

const {
  data,
  width = 800,
  height = 500,
  title = "Energy Profile Diagram",
  yLabel = "Energy",
  xLabel = "Reaction Coordinate",
  energyUnit = "kcal/mol",
  colors = {
    line: "#0066CC",
    point: "#0066CC",
    text: "#333333",
    transitionState: "#CC0000",
    background: "#FFFFFF",
  },
  fontSize = 14,
  lineWidth = 2,
} = Astro.props;

// Generate a unique ID for the canvas element
const canvasId = `energy-diagram-${Math.random().toString(36).substring(2, 9)}`;
---

<div class="energy-diagram-container" style={`width: ${width}px; height: ${height}px;`}>
  <canvas id={canvasId} width={width} height={height}></canvas>
</div>

<script define:vars={{ data, canvasId, title, yLabel, xLabel, energyUnit, colors, fontSize, lineWidth, width, height }}>
  // Function to draw the energy diagram
  function drawEnergyDiagram() {
    try {
      const canvas = document.getElementById(canvasId);
      if (!canvas) {
        console.error(`Canvas element with id ${canvasId} not found. Will retry in 100ms.`);
        // Retry after a short delay
        setTimeout(drawEnergyDiagram, 100);
        return;
      }
      
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Could not get 2D context from canvas');
        return;
      }
      
      // Calculate margins and plot area dimensions
      const margin = {
        top: 50,
        right: 50,
        bottom: 70,
        left: 80
      };
      const plotWidth = width - margin.left - margin.right;
      const plotHeight = height - margin.top - margin.bottom;
      
      // Find min and max energy values for scaling
      const energies = data.map(point => point.energy);
      const minEnergy = Math.min(...energies);
      const maxEnergy = Math.max(...energies);
      const energyRange = maxEnergy - minEnergy;
      
      // Add 10% padding to energy range
      const paddedMinEnergy = minEnergy - (energyRange * 0.1);
      const paddedMaxEnergy = maxEnergy + (energyRange * 0.1);
      
      // Function to convert energy value to Y coordinate
      const energyToY = (energy) => {
        return margin.top + plotHeight - ((energy - paddedMinEnergy) / (paddedMaxEnergy - paddedMinEnergy) * plotHeight);
      };
      
      // Function to calculate X coordinate based on index
      const indexToX = (index) => {
        const segmentWidth = plotWidth / (data.length - 1);
        return margin.left + (index * segmentWidth);
      };
      
      // Clear canvas
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, width, height);
      
      // Draw title
      ctx.fillStyle = colors.text;
      ctx.font = `bold ${fontSize + 4}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText(title, width / 2, margin.top / 2);
      
      // Draw y-axis
      ctx.beginPath();
      ctx.strokeStyle = colors.text;
      ctx.lineWidth = 1;
      ctx.moveTo(margin.left, margin.top);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.stroke();
      
      // Draw x-axis
      ctx.beginPath();
      ctx.moveTo(margin.left, height - margin.bottom);
      ctx.lineTo(width - margin.right, height - margin.bottom);
      ctx.stroke();
      
      // Draw y-axis label
      ctx.save();
      ctx.translate(margin.left / 3, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.font = `${fontSize}px Arial`;
      ctx.fillText(`${yLabel} (${energyUnit})`, 0, 0);
      ctx.restore();
      
      // Draw x-axis label
      ctx.textAlign = 'center';
      ctx.fillText(xLabel, width / 2, height - margin.bottom / 3);
      
      // Draw grid lines
      // Calculate reasonable y-axis tick intervals
      const energyStep = calculateNiceStep(paddedMinEnergy, paddedMaxEnergy);
      let tickValue = Math.ceil(paddedMinEnergy / energyStep) * energyStep;
      
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.setLineDash([5, 5]);
      
      while (tickValue < paddedMaxEnergy) {
        const yPos = energyToY(tickValue);
        
        // Draw horizontal grid line
        ctx.beginPath();
        ctx.moveTo(margin.left, yPos);
        ctx.lineTo(width - margin.right, yPos);
        ctx.stroke();
        
        // Draw y-axis tick label
        ctx.fillStyle = colors.text;
        ctx.textAlign = 'right';
        ctx.fillText(tickValue.toFixed(1), margin.left - 10, yPos + 4);
        
        tickValue += energyStep;
      }
      
      ctx.setLineDash([]);
      
      // Draw the energy profile diagram with connecting lines
      for (let i = 0; i < data.length - 1; i++) {
        const x1 = indexToX(i);
        const y1 = energyToY(data[i].energy);
        const x2 = indexToX(i + 1);
        const y2 = energyToY(data[i + 1].energy);
        
        // Draw point (circle for stable states, triangle for transition states)
        ctx.fillStyle = data[i].transitionState ? colors.transitionState : colors.point;
        ctx.beginPath();
        
        if (data[i].transitionState) {
          // Draw triangle for transition state
          const triangleSize = 8;
          ctx.moveTo(x1, y1 - triangleSize);
          ctx.lineTo(x1 - triangleSize, y1 + triangleSize);
          ctx.lineTo(x1 + triangleSize, y1 + triangleSize);
          ctx.closePath();
        } else {
          // Draw circle for stable state
          ctx.arc(x1, y1, 6, 0, Math.PI * 2);
        }
        
        ctx.fill();
        
        // Draw point label
        ctx.fillStyle = colors.text;
        ctx.textAlign = 'center';
        ctx.fillText(data[i].name, x1, y1 + (data[i].transitionState ? 30 : 20));
        ctx.fillText(data[i].energy.toFixed(1) + " " + energyUnit, x1, y1 - 15);
        
        // Draw line connecting points
        ctx.beginPath();
        ctx.strokeStyle = colors.line;
        ctx.lineWidth = lineWidth;
        ctx.moveTo(x1, y1);
        
        // Draw direct diagonal line between points
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      
      // Draw the last point
      const lastIndex = data.length - 1;
      const lastX = indexToX(lastIndex);
      const lastY = energyToY(data[lastIndex].energy);
      
      ctx.fillStyle = data[lastIndex].transitionState ? colors.transitionState : colors.point;
      ctx.beginPath();
      
      if (data[lastIndex].transitionState) {
        // Draw triangle for transition state
        const triangleSize = 8;
        ctx.moveTo(lastX, lastY - triangleSize);
        ctx.lineTo(lastX - triangleSize, lastY + triangleSize);
        ctx.lineTo(lastX + triangleSize, lastY + triangleSize);
        ctx.closePath();
      } else {
        // Draw circle for stable state
        ctx.arc(lastX, lastY, 6, 0, Math.PI * 2);
      }
      
      ctx.fill();
      
      // Draw last point label
      ctx.fillStyle = colors.text;
      ctx.textAlign = 'center';
      ctx.fillText(data[lastIndex].name, lastX, lastY + (data[lastIndex].transitionState ? 30 : 20));
      ctx.fillText(data[lastIndex].energy.toFixed(1) + " " + energyUnit, lastX, lastY - 15);
      
      // Draw x-axis tick marks and labels
      for (let i = 0; i < data.length; i++) {
        const x = indexToX(i);
        
        // Draw tick mark
        ctx.beginPath();
        ctx.strokeStyle = colors.text;
        ctx.lineWidth = 1;
        ctx.moveTo(x, height - margin.bottom);
        ctx.lineTo(x, height - margin.bottom + 5);
        ctx.stroke();
        
        // Draw abbreviated reaction step number
        ctx.fillStyle = colors.text;
        ctx.textAlign = 'center';
        ctx.fillText(i + 1, x, height - margin.bottom + 20);
      }
      
      console.log(`Energy diagram ${canvasId} created successfully`);
    } catch (error) {
      console.error("Failed to create energy diagram:", error);
    }
  }
  
  // Helper function to calculate nice step sizes for axis ticks
  function calculateNiceStep(min, max) {
    const range = max - min;
    const magnitude = Math.pow(10, Math.floor(Math.log10(range)));
    const residual = range / magnitude;
    
    let niceFraction;
    if (residual < 1.5) {
      niceFraction = 1;
    } else if (residual < 3) {
      niceFraction = 2;
    } else if (residual < 7) {
      niceFraction = 5;
    } else {
      niceFraction = 10;
    }
    
    return niceFraction * magnitude / 5;
  }

  // Initialize the diagram as soon as possible
  drawEnergyDiagram();

  // But also ensure it runs on DOMContentLoaded as a fallback
  document.addEventListener('DOMContentLoaded', function() {
    console.log(`DOMContentLoaded event fired, ensuring diagram ${canvasId} is drawn`);
    // Wait a moment to ensure all elements are fully rendered
    setTimeout(drawEnergyDiagram, 10);
  });

  // Add a window load event as a final fallback
  window.addEventListener('load', function() {
    console.log(`Window load event fired, ensuring diagram ${canvasId} is drawn`);
    // Wait a moment to ensure all elements are fully rendered
    setTimeout(drawEnergyDiagram, 50);
  });

  // Add resize handler
  window.addEventListener('resize', function() {
    console.log(`Window resize event detected, redrawing diagram ${canvasId}`);
    drawEnergyDiagram();
  });
</script>

<style>
  .energy-diagram-container {
    margin: 1rem 0;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    padding: 16px;
    background-color: white;
  }

  /* Ensure canvas is responsive */
  canvas {
    max-width: 100%;
    height: auto;
  }
</style>
