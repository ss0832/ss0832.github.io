---
// EnergyDiagram.astro - Energy profile diagram component for Astro


interface EnergyPoint {
  name: string;
  energy: number;
  transitionState?: boolean;
}

interface Props {
  data: EnergyPoint[];
  width?: number;
  height?: number;
  title?: string;
  yLabel?: string;
  xLabel?: string;
  energyUnit?: string;
  colors?: {
    line?: string;
    point?: string;
    text?: string;
    transitionState?: string;
    background?: string;
  };
  fontSize?: number;
  lineWidth?: number;
  horizontalLength?: number;
}

const {
  data,
  width = 800,
  height = 500,
  title = "Energy Profile Diagram",
  yLabel = "Energy",
  xLabel = "Reaction Coordinate",
  energyUnit = "kcal/mol",
  colors = {
    line: "#0066CC",
    point: "#0066CC",
    text: "#333333",
    transitionState: "#CC0000",
    background: "#FFFFFF",
  },
  fontSize = 14,
  lineWidth = 2,
  horizontalLength = 40,
} = Astro.props;

// Generate a unique ID for the canvas element
const canvasId = `energy-diagram-${Math.random().toString(36).substring(2, 9)}`;
---

<div class="energy-diagram-container" style={`width: ${width}px; height: ${height}px;`}>
  <canvas id={canvasId} width={width} height={height}></canvas>
</div>

<script define:vars={{ data, canvasId, title, yLabel, xLabel, energyUnit, colors, fontSize, lineWidth, width, height, horizontalLength }}>
  // Function to draw the energy diagram
  function drawEnergyDiagram() {
    try {
      const canvas = document.getElementById(canvasId);
      if (!canvas) {
        console.error(`Canvas element with id ${canvasId} not found. Will retry in 100ms.`);
        // Retry after a short delay
        setTimeout(drawEnergyDiagram, 100);
        return;
      }
      
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Could not get 2D context from canvas');
        return;
      }
      
      // Calculate margins and plot area dimensions
      const margin = {
        top: 50,
        right: 60,
        bottom: 70,
        left: 80
      };
      const plotWidth = width - margin.left - margin.right;
      const plotHeight = height - margin.top - margin.bottom;
      
      // Find min and max energy values for scaling
      const energies = data.map(point => point.energy);
      const minEnergy = Math.min(...energies);
      const maxEnergy = Math.max(...energies);
      const energyRange = maxEnergy - minEnergy;
      
      // Add 15% padding to energy range for better visualization
      const paddedMinEnergy = minEnergy - (energyRange * 0.15);
      const paddedMaxEnergy = maxEnergy + (energyRange * 0.15);
      
      // Function to convert energy value to Y coordinate
      const energyToY = (energy) => {
        return margin.top + plotHeight - ((energy - paddedMinEnergy) / (paddedMaxEnergy - paddedMinEnergy) * plotHeight);
      };
      
      // Calculate X coordinates for each point
      // This is more complex for PyEnergyDiagrams style with horizontal segments
      const points = [];
      let totalX = margin.left;
      
      for (let i = 0; i < data.length; i++) {
        const y = energyToY(data[i].energy);
        
        // For transition states, we don't add horizontal segments
        if (!data[i].transitionState) {
          points.push({
            x: totalX,
            y: y,
            energy: data[i].energy,
            name: data[i].name,
            isTS: false,
            leftX: totalX - horizontalLength/2,
            rightX: totalX + horizontalLength/2
          });
          
          totalX += horizontalLength * 2; // More space between stable states
        } else {
          // For transition states, position between the previous and next points
          points.push({
            x: totalX,
            y: y,
            energy: data[i].energy,
            name: data[i].name,
            isTS: true,
            leftX: totalX,
            rightX: totalX
          });
          
          totalX += horizontalLength; // Less space after transition states
        }
      }
      
      // Clear canvas
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, width, height);
      
      // Draw title
      ctx.fillStyle = colors.text;
      ctx.font = `bold ${fontSize + 6}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText(title, width / 2, margin.top / 2);
      
      // Draw y-axis
      ctx.beginPath();
      ctx.strokeStyle = colors.text;
      ctx.lineWidth = 1;
      ctx.moveTo(margin.left, margin.top);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.stroke();
      
      // Draw x-axis
      ctx.beginPath();
      ctx.moveTo(margin.left, height - margin.bottom);
      ctx.lineTo(width - margin.right, height - margin.bottom);
      ctx.stroke();
      
      // Draw y-axis label
      ctx.save();
      ctx.translate(margin.left / 3, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.font = `${fontSize + 2}px Arial`;
      ctx.fillText(`${yLabel} (${energyUnit})`, 0, 0);
      ctx.restore();
      
      // Draw x-axis label
      ctx.textAlign = 'center';
      ctx.font = `${fontSize + 2}px Arial`;
      ctx.fillText(xLabel, width / 2, height - margin.bottom / 3);
      
      // Draw grid lines
      // Calculate reasonable y-axis tick intervals
      const energyStep = calculateNiceStep(paddedMinEnergy, paddedMaxEnergy);
      let tickValue = Math.ceil(paddedMinEnergy / energyStep) * energyStep;
      
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.setLineDash([5, 5]);
      
      while (tickValue < paddedMaxEnergy) {
        const yPos = energyToY(tickValue);
        
        // Draw horizontal grid line
        ctx.beginPath();
        ctx.moveTo(margin.left, yPos);
        ctx.lineTo(width - margin.right, yPos);
        ctx.stroke();
        
        // Draw y-axis tick label
        ctx.fillStyle = colors.text;
        ctx.textAlign = 'right';
        ctx.font = `${fontSize}px Arial`;
        ctx.fillText(tickValue.toFixed(1), margin.left - 10, yPos + 4);
        
        tickValue += energyStep;
      }
      
      ctx.setLineDash([]);
      
      // Draw the energy profile diagram with PyEnergyDiagrams style
      // First, draw all connecting lines
      for (let i = 0; i < points.length - 1; i++) {
        ctx.beginPath();
        ctx.strokeStyle = colors.line;
        ctx.lineWidth = lineWidth;
        
        const current = points[i];
        const next = points[i + 1];
        
        if (!current.isTS) {
          // Draw horizontal line for stable state
          ctx.moveTo(current.leftX, current.y);
          ctx.lineTo(current.rightX, current.y);
        }
        
        // Draw connecting line to the next point
        ctx.moveTo(current.rightX, current.y);
        
        if (next.isTS) {
          // Direct line to transition state
          ctx.lineTo(next.x, next.y);
        } else {
          // Direct line to the left side of next stable state
          ctx.lineTo(next.leftX, next.y);
        }
        
        ctx.stroke();
      }
      
      // Draw the last point's horizontal line if it's not a transition state
      const lastPoint = points[points.length - 1];
      if (!lastPoint.isTS) {
        ctx.beginPath();
        ctx.strokeStyle = colors.line;
        ctx.lineWidth = lineWidth;
        ctx.moveTo(lastPoint.leftX, lastPoint.y);
        ctx.lineTo(lastPoint.rightX, lastPoint.y);
        ctx.stroke();
      }
      
      // Now draw all points on top of the lines
      for (let i = 0; i < points.length; i++) {
        const point = points[i];
        
        // Draw different markers for transition states vs stable states
        if (point.isTS) {
          // Transition state - draw red X marker
          ctx.fillStyle = colors.transitionState;
          ctx.strokeStyle = colors.transitionState;
          ctx.lineWidth = 2;
          
          // Draw X marker
          const markerSize = 6;
          ctx.beginPath();
          ctx.moveTo(point.x - markerSize, point.y - markerSize);
          ctx.lineTo(point.x + markerSize, point.y + markerSize);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(point.x - markerSize, point.y + markerSize);
          ctx.lineTo(point.x + markerSize, point.y - markerSize);
          ctx.stroke();
          
          // Draw name above the point for transition states
          ctx.fillStyle = colors.text;
          ctx.textAlign = 'center';
          ctx.font = `${fontSize}px Arial`;
          ctx.fillText(point.name, point.x, point.y - 12);
          
          // Draw energy value below the point
          ctx.fillText(point.energy.toFixed(1) + " " + energyUnit, point.x, point.y + 20);
        } else {
          // Stable state - draw filled circle
          ctx.fillStyle = colors.point;
          ctx.beginPath();
          ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw name below the point for stable states
          ctx.fillStyle = colors.text;
          ctx.textAlign = 'center';
          ctx.font = `${fontSize}px Arial`;
          ctx.fillText(point.name, point.x, point.y + 20);
          
          // Draw energy value above the point
          ctx.fillText(point.energy.toFixed(1) + " " + energyUnit, point.x, point.y - 12);
        }
      }
      
      // Draw dotted reference line at zero if within the energy range
      if (paddedMinEnergy < 0 && paddedMaxEnergy > 0) {
        const zeroY = energyToY(0);
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 2]);
        ctx.moveTo(margin.left, zeroY);
        ctx.lineTo(width - margin.right, zeroY);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      console.log(`Energy diagram ${canvasId} created successfully in PyEnergyDiagrams style`);
    } catch (error) {
      console.error("Failed to create energy diagram:", error);
    }
  }
  
  // Helper function to calculate nice step sizes for axis ticks
  function calculateNiceStep(min, max) {
    const range = max - min;
    const magnitude = Math.pow(10, Math.floor(Math.log10(range)));
    const residual = range / magnitude;
    
    let niceFraction;
    if (residual < 1.5) {
      niceFraction = 1;
    } else if (residual < 3) {
      niceFraction = 2;
    } else if (residual < 7) {
      niceFraction = 5;
    } else {
      niceFraction = 10;
    }
    
    return niceFraction * magnitude / 5;
  }

  // Initialize the diagram as soon as possible
  drawEnergyDiagram();

  // But also ensure it runs on DOMContentLoaded as a fallback
  document.addEventListener('DOMContentLoaded', function() {
    // Wait a moment to ensure all elements are fully rendered
    setTimeout(drawEnergyDiagram, 10);
  });

  // Add a window load event as a final fallback
  window.addEventListener('load', function() {
    // Wait a moment to ensure all elements are fully rendered
    setTimeout(drawEnergyDiagram, 50);
  });

  // Add resize handler
  window.addEventListener('resize', function() {
    drawEnergyDiagram();
  });
</script>

<style>
  .energy-diagram-container {
    margin: 1rem auto;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    padding: 16px;
    background-color: white;
    display: flex;
    justify-content: center;
  }

  /* Ensure canvas is responsive */
  canvas {
    max-width: 100%;
    height: auto;
  }
</style>
